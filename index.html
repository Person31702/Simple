<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Canvas Character Movement</title>
    <style>
        body { margin: 0; }
        canvas { position: absolute; display: block; background: #f0f0f0; z-index: 0; }
        button { position: absolute; z-index: 1; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button id="startGameButton"></button>
    <script>

const gameCanvas = {
    element: null,
    context: null,
    width: null,
    height: null,
    backgroundLineSpacing: null,
    initialize: function() {
        this.element = document.getElementById('gameCanvas');
        this.context = this.element.getContext('2d');
        this.width = (this.element.width = window.innerWidth * 0.75);
        this.height = (this.element.height = window.innerHeight);
        this.backgroundLineSpacing = 50;
        this.element.style.left = window.innerWidth * 0.25 / 2 + 'px';
        this.element.style.top = '0px';
        this.element.style.display = 'none';
        this.context.translate(this.width / 2, this.height / 2);
    },
    clear: function() {
        this.context.save();
        this.context.setTransform(1, 0, 0, 1, 0, 0); // Reset transform to identity
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.restore();
    },
    drawBackgroundLines: function() {
        let spacing = this.backgroundLineSpacing;
        // Get the four corners of the canvas in screen space
        let corners = [
            {x: 0, y: 0},
            {x: this.width, y: 0},
            {x: this.width, y: this.height},
            {x: 0, y: this.height}
        ];

        // Transform each corner to world space
        let worldCorners = corners.map(corner => {
            // Center canvas
            let x = corner.x - this.width / 2;
            let y = corner.y - this.height / 2;
            // Undo zoom
            x /= gameCamera.zoom;
            y /= gameCamera.zoom;
            // Undo rotation
            let cos = Math.cos(gameCamera.angle);
            let sin = Math.sin(gameCamera.angle);
            let worldX = x * cos - y * sin + gameCamera.x;
            let worldY = x * sin + y * cos + gameCamera.y;
            return {x: worldX, y: worldY};
        });

        // Find min/max bounds in world space
        let minX = Math.min(...worldCorners.map(p => p.x));
        let maxX = Math.max(...worldCorners.map(p => p.x));
        let minY = Math.min(...worldCorners.map(p => p.y));
        let maxY = Math.max(...worldCorners.map(p => p.y));

        // Align grid lines to spacing
        let startX = Math.floor(minX / spacing) * spacing;
        let endX = Math.ceil(maxX / spacing) * spacing;
        let startY = Math.floor(minY / spacing) * spacing;
        let endY = Math.ceil(maxY / spacing) * spacing;

        this.context.save();
        this.context.rotate(-gameCamera.angle);
        this.context.scale(gameCamera.zoom, gameCamera.zoom);
        this.context.translate(-gameCamera.x, -gameCamera.y);
        this.context.strokeStyle = 'black';
        this.context.lineWidth = 1;
        this.context.beginPath();
        for (let x = startX; x <= endX; x += spacing) {
            this.context.moveTo(x, startY);
            this.context.lineTo(x, endY);
        }
        for (let y = startY; y <= endY; y += spacing) {
            this.context.moveTo(startX, y);
            this.context.lineTo(endX, y);
        }
        this.context.stroke();
        this.context.closePath();
        this.context.restore();
    },
    drawCircle: function(sprite) {
        this.context.save();
        this.context.rotate(-gameCamera.angle);
        this.context.scale(gameCamera.zoom, gameCamera.zoom);
        this.context.translate(-gameCamera.x, -gameCamera.y);
        this.context.fillStyle = sprite.color;
        this.context.beginPath();
        this.context.arc(sprite.x, sprite.y, sprite.radius, 0, Math.PI * 2);
        this.context.fill();
        this.context.closePath();
        this.context.restore();
    },
    hide: function() {
        this.element.style.display = 'none';
    },
    show: function() {
        this.element.style.display = 'block';
    }
};

const gameCamera = {
    x: null,
    y: null,
    zoom: null,
    angle: null,
    initialize: function() {
        this.x = 0;
        this.y = 0;
        this.zoom = 1;
        this.angle = 0;
    }
}

const player = {
    x: null,
    y: null,
    radius: null,
    color: null,
    speed: null,
    initialize: function() {
        this.x = 0;
        this.y = 0;
        this.radius = 20;
        this.color = 'green';
        this.speed = 2;
    }
};

const startGameButton = {
    element: null,
    width: null,
    height: null,
    initialize: function() {
        this.element = document.getElementById('startGameButton');
        this.width = 100;
        this.height = 50;
        this.element.style.width = this.width + 'px';
        this.element.style.height = this.height + 'px';
        this.element.style.left = window.innerWidth / 2 - this.width / 2 + 'px';
        this.element.style.top = window.innerHeight / 2 - this.height / 2 + 'px';
        this.element.innerText = 'Start Game';
        this.element.onclick = function() {
            startGame();
        };
    },
    hide: function() {
        this.element.style.display = 'none';
    }
};

const keys = [];
for (let i = 0; i < 128; ++i) {
    keys.push([false, false]);
}
document.addEventListener('keydown', function(event) {
    if (event.key.charCodeAt(0) >= 0 && event.key.charCodeAt(0) < 128) {
        keys[event.key.charCodeAt(0)][0] = true;
    }
    else {
        console.log("key '" + event.key + "'(code " + event.key.charCodeAt(0) + ") out of range");
    }
})
document.addEventListener('keyup', function(event) {
    if (event.key.charCodeAt(0) >= 0 && event.key.charCodeAt(0) < 128) {
        keys[event.key.charCodeAt(0)][0] = false;
    }
    else {
        console.log("key '" + event.key + "'(code " + event.key.charCodeAt(0) + ") out of range");
    }
})
function keyPressed(key) {
    return keys[key.charCodeAt(0)][0];
}
function keyJustPressed(key) {
    return keys[key.charCodeAt(0)][0] && !keys[key.charCodeAt(0)][1];
}

function startGame() {
    startGameButton.hide();
    gameCanvas.show();
    gameLoop();
}

function gameLoop() {
    let xKeys = keyPressed('d') - keyPressed('a');
    let yKeys = keyPressed('s') - keyPressed('w');
    if (xKeys != 0 || yKeys != 0) {
        let hypotenuse = Math.sqrt(xKeys * xKeys + yKeys * yKeys);
        player.x += player.speed * xKeys / hypotenuse;
        player.y += player.speed * yKeys / hypotenuse;
    }
    if (keyJustPressed('q')) {
        gameCamera.zoom /= 1.1;
    }
    if (keyJustPressed('e')) {
        gameCamera.zoom *= 1.1;
    }
    if (keyPressed('q') && keyPressed('e')) {
        gameCamera.zoom = 1;
    }
    gameCamera.x = player.x;
    gameCamera.y = player.y;
    gameCanvas.clear();
    gameCanvas.drawBackgroundLines();
    gameCanvas.drawCircle(player);

    for (let i = 0; i < 128; ++i) {
        keys[i][1] = keys[i][0];
    }
    requestAnimationFrame(gameLoop);
}
gameCanvas.initialize();
gameCamera.initialize();
player.initialize();
startGameButton.initialize();

    </script>
</body>
</html>
